%{
    #include <stdlib.h>
    #include <stdio.h>
    int yylex(void);
    void yyerror (char const *);
    #define YYERROR_VERBOSE
    // #define YYDEBUG 1 
    #define YYSTYPE int    
    extern int yylval;     
    extern char yytext[]; 
    extern FILE * yyin;    
    extern int yylineno; //Linea de la instrucci√≥n
%}

%token NUMERO OPEN UPDATE ADD INSERT WARNING ALIGN CONTINUE ANALOGREAD ANALOGREFERENCE ANALOGWRITE DOCUMENTID FILETYPEFILETYPEEXTENSION INSTANCEID LINEARIZEDMIMETYPE PAGECOUNT PAGELAYOUTPDFVERSION TAGGEDPDF XMPTOOLKIT ARRAY NOTONE PULSEIN SHIFTIN SHIFTOUT TONE BOOL_LITERAL DEL CLOSE FINALLY ASYNC DO FOR WHILE CLASS SQL COLOR ADJUSTFIELD BASEFIELD FLOATFIELD AS CROSSJOIN DISTINCTEXCEPT FULLOUTERJOIN JOIN LIKE WHEN WHERE BOOLEAN MATH MATH_E MATH_LN10 MATH_LN2 MATH_LOG10E MATH_LOG2E MATH_PIMATH_SQRT1 MATH_SQRT2 R_BRACKET L_BRACKET TBODY GLOBAL VAL VAR LET FILL PRECISION BORDER TD TR COLSPAN GET DIGITALREAD DIGITALWRITE PINMODE COLON DEBUGGER TH THEAD CIN INPUT PRINTLN CHECKED LOOP SETUP ELIF ELSE CATCH EXCEPT IOTA ISNAN NAN RAISE VOID CIRCLE RECTANGLE SQUARE TRIANGLE FORMAT FONT FUN SQLCOMMAND SQLCONNECTION ABS ATN COS DERIVED MATHEXP FIX LOG RND SGN SIN SQR TAN LAMBDA CREATEDATE DATE DATEVALUEDAY DAYS360 EDATE HOUR MINUTE MODIFYDATE MONTH NETWORKDAYS NOW SECOND TIME TIMEVALUE TODAY WEEKDAY WEEKNUMWORKDAY YEAR CLEARDEVICE CLEARVIEWPORT CLOSEGRAPH DETECTGRAPH GETARCCOORDS GETASPECTRAT INHEREIT CREATORTOOL LENGUAGE IDENT IMPORT INCLUDE_ONCE STYLE FLAGS SETF DISABLE ENABLE HEIGHTHIDE LOCATION POINT SHOW SIZE RETURN WITH INCLUDE LIST R_BRACE L_BRACE IN ENDL FLUSH SETFILL SETIOSFLAG SETPRECISION SETWUNSETIOSFLAG FRAME MAXINT MESSAGEBOX CONSTMUT EXTERN INTERN NATIVE OUT SEALED UNSAFE METADATADATE FROM INTO SHOWBASE _NULL NAME SRC NEW NONE DIALUP DIGESTAUTH NTAUTHORITY NTDOMAIN NTLMAUTH TFOOT PASS IF TRY MAINPR RESTRICTED UNARYPLUS DOT SEMICOLON AWAIT PAUSE L_PAR R_PAR PARAMS PACKAGE ORDER SORT ADDITION ASSIGNMENTOPERATOR CAPITALIZE DOWNCASE EMPTY GSUB UPCASE PLUS MINUS MULT DIV OBJECT RANDOM RANDOMSEED EQ GT LT NOT COMP QUESTION EQEQ LTEQ GTEQ NOTEQ ANDAND OROR PLUSPLUS MINUSMINUS AND OR XOR MOD LSHIFT RSHIFT URSHIFT PLUSEQ MINUSEQ MULTEQ DIVEQ ANDEQ OREQ XOREQ MODEQ LSHIFTEQ RSHIFTEQ URSHIFTEQ COMMA PUBLIC PRIVATE PROTECTED STATIC FOREACH SWITCH DEFAULT CASE BREAK VARCHAR BIT DATETIME DECIMAL MONEY NUMERIC REAL SMALLINT SMALLDATETIME TINYINT BINARY VARBINARY IMAGE TEXT INTEGER WCHART BOOL LONGLONG LONGDOUBLE WIDECHAR UNSIGNEDINT UNSIGNEDLONG STRING STRINGUPPERCASE BYTE CHAR INT LONG SHORT DOUBLE FLOAT IDENTIFIER

%start program
%left PLUS MINUS
%left MULT DIV
%%
program : statement
    | statement program;
statement : assignment SEMICOLON // x = 5;
    |IFComplete // if (x == 5) {}
    |TryComplete // try {} catch {}
    |DECLAREFUNCTION // public static void x() {}
    |DECLAREVARIABLE SEMICOLON // int x;
    |DECLARECLASS // public class x {}
    |DOLOOP SEMICOLON // do {} while (x == 5);
    |WHILELOOP // while (x == 5) {}
    |FORLOOP // for (int i = 0; i < 5; i++) {}
    |UNARYARITMETICEXPR SEMICOLON // x++;
    |LAMBDAFUNCTION // () >> {} 
    |DECLAREARRAY SEMICOLON // int[] x; 
    |FOREACHLOOP // foreach (int i in x) {}
    |SWITCHCONDITION // switch (x) {}
    |error // error
    |LlamarFuncion
    ;

assignment : IDENTIFIER EQ expr; //x1 = 5;

expr: expr PLUS expr // x + 1
    | expr MINUS expr // x - 1
    | expr MULT expr // x * 2
    | expr DIV expr // x/ 4
    | expr MOD expr // 3 % 2 * 3
    | L_PAR expr R_PAR // (2 * 3)
    | NUMERO // 3
    | IDENTIFIER // x
    | expr MULT MULT expr // a ** b
    | OR expr OR // | a |
    ;

IFComplete : IFSegment ElseSegment;

IFSegment : IF CONDICION LCUSTOM program RCUSTOM; // if (x == 5) {}
ElseSegment : ELIF CONDICION LCUSTOM program RCUSTOM ElseSegment // else if (x == 5) {}
    |ELSE LCUSTOM program RCUSTOM // else {}
    |; // if (x == 5) {} else if (x == 5) {} else {}
CONDICION : FRAGMENTOCONDICION // x == 5
    |FRAGMENTOCONDICION OPLOGICOBIN CONDICION // x == 5 && x == 5
    |BOOL_LITERAL; // true
FRAGMENTOCONDICION : expr OPRELACIONALBIN expr; // x == 5
OPRELACIONALBIN : EQEQ // ==
    |NOTEQ // !=
    |LT // <
    |LTEQ // <=
    |GT // >
    |GTEQ // >=
    ; // x == 5 
OPLOGICOBIN : ANDAND // &&
    |OROR // ||
    |XOR // ^
    ; // x == 5 && x == 5

TryComplete : TrySegment
    |TrySegment CatchSegment;
TrySegment : TRY L_BRACE program R_BRACE;
CatchSegment : CATCH ARGUMENTS L_BRACE program R_BRACE;
ARGUMENTS : expr
    |expr ARGUMENT
    |;
ARGUMENT : COMMA expr //crea recursividad
    |COMMA expr ARGUMENT;
    
PARAMETERS : DATATYPE IDENTIFIER
    |DATATYPE IDENTIFIER PARAMETER
    |;
PARAMETER : COMMA DATATYPE IDENTIFIER
    | COMMA DATATYPE IDENTIFIER PARAMETER;

DECLARECLASS : ACCESSMODIFIER CLASS IDENTIFIER HERENCYSEGMENT L_BRACE program R_BRACE;

HERENCYSEGMENT : EXTENDSEGMENT
    |IMPLEMENTSEGMENT
    |;

EXTENDSEGMENT : LTEQ IDENTIFIER;

IMPLEMENTSEGMENT : EQ GT IDENTIFIER;

DECLAREFUNCTION : ACCESSMODIFIER STATICMODIFIER FUNCTIONRETURNTYPE IDENTIFIER L_PAR PARAMETERS R_PAR L_BRACE program R_BRACE;

FUNCTIONRETURNTYPE : VOID
    |DATATYPE;

STATICMODIFIER : STATIC
    |;

ACCESSMODIFIER : PUBLIC
    |PRIVATE
    |PROTECTED;

DATATYPE : INT
    |LONG
    |BOOLEAN
    |BOOL
    |SHORT
    |CHAR
    |BYTE
    |DOUBLE
    |FLOAT
    |STRING
    |STRINGUPPERCASE
    |UNSIGNEDINT
    |UNSIGNEDLONG
    ;

DECLAREVARIABLE : DATATYPE IDENTIFIER
    |DATATYPE IDENTIFIER EQ expr;

DOLOOP : DO L_BRACE program R_BRACE WHILE L_PAR CONDICION R_PAR;

WHILELOOP : WHILE L_PAR CONDICION R_PAR L_BRACE program R_BRACE;

FORLOOP : FOR L_PAR FORSTATEMENTS R_PAR L_BRACE program R_BRACE;

FORSTATEMENTS : assignment SEMICOLON CONDICION SEMICOLON assignment;

UNARYARITMETICEXPR : IDENTIFIER PLUSPLUS
    |IDENTIFIER MINUSMINUS;

LAMBDAFUNCTION : L_PAR PARAMETERS R_PAR RSHIFT LCUSTOM program RCUSTOM;

/* Propias */

DECLAREARRAY : ARRAY IDENTIFIER EQ ARRAYDIMENSIONS;

ARRAYDIMENSIONS : NUMERO
    |NUMERO COMMA ARRAYDIMENSIONS;

FOREACHLOOP : FOREACH IDENTIFIER EQ GT IDENTIFIER LCUSTOM program RCUSTOM;

LCUSTOM : COLON MINUS;
RCUSTOM : MINUS COLON;

SWITCHCONDITION : SWITCH expr LCUSTOM SWITCHOPTIONS RCUSTOM;

SWITCHOPTIONS : CASESTATEMENT SWITCHOPTIONS
    |DEFAULTSTATEMENT ONLYCASEOPTIONS
    |;
ONLYCASEOPTIONS : CASESTATEMENT ONLYCASEOPTIONS
    |;
DEFAULTSTATEMENT : DEFAULT LCUSTOM program BREAK SEMICOLON RCUSTOM;
CASESTATEMENT :
    CASE NUMERO LCUSTOM
        program
    BREAK SEMICOLON
    RCUSTOM;
LlamarFuncion : IDENTIFIER L_PAR ARGUMENTS R_PAR SEMICOLON; // x();
%%
int main(int argc, char* *argv){
    /* yydebug = 1; */
    char ch,c;
    FILE *f;    
    if(argc != 2) {
        printf("Uso: archivo de entrada\n"); 
        exit(1);
    }
    if( !(yyin = fopen(argv[1],"r")) ){ 
        printf("No se puede abrir el archivo\n");
        exit(1);
    }
    yyparse();
    printf("Compilacion exitosa\n");
}

void yyerror(char const *s){
    fprintf(stderr,"error: %s in line %d\n", s, yylineno);
    exit(1);
}
